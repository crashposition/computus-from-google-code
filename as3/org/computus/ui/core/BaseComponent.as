/*		====================================================================================	2009 | John Dalziel  | The Computus Engine  |  http://www.computus.org	All source code licenced under The MIT Licence	====================================================================================  */package org.computus.ui.core{	import flash.events.Event;	import flash.display.MovieClip;		/**	 * The BaseComponent class is intended to be used as a base class for other AS3 MovieClips.	 * The class is light and simple and aims to simplify garbage and render management of custom AS3 MovieClips and components.	 * 	 * <p>implements "Garbage Management" through standardised and automated init() and destroy() functions</p>	 * <p><b>init()</b><br/>	 * This function is automatically called when the component is added to the stage either by placing it on the timeline or by addChild() in AS3.	 * You should place all your initialisation code and add any listeners here.</p>	 * 	 * <p><b>destroy()</b><br/>	 * This function is automatically called when the component is removed from the stage either by removing it from the timeline or by removeChild() in AS3.	 * You should place all your cleanup code and remove any listeners here.</p>  	 * 	 * <p>implements "deferred rendering" through invalidate() and draw()<p> 	 * <p><b>invalidate()</b><br/>	 * This function can be used to queue a draw() request at the next available frame.</p>	 * 	 * <p><b>draw()</b><br/>	 * This function can be used to redraw the state of a complicated component. It can either be called directly or buffered and scheduled by calling the invalidate() command.	 * You should place any state redraw code here.</p>  	 */	public class BaseComponent extends MovieClip	{	// ------------------------------------------	// PROPERTIES	// ------------------------------------------	// CONSTRUCTOR		/**		 * Creates a new instance of the BaseComponent() class.		 */		public function BaseComponent():void		{			super()						// n.b. These events require a minimum Flash Player version of 9.0.28.0			addEventListener( Event.ADDED_TO_STAGE, onAddedToStage, false, 0, true )			addEventListener( Event.REMOVED_FROM_STAGE, onRemovedFromStage, false, 0, true )		}			// ------------------------------------------	// MEMORY MANAGEMENT		/**		 * This function is called whenever the component is added to the DisplayList. 		 * 		 * <p>Concrete classes should always override this function. The overridden function should contain everything required to initialise the component. This can include any of the following:		 * <ul><li>manage any child components</li>		 * <li>add any event listeners</li>		 * <li>initialise any intervals</li>		 * <li>initialise any Timers</li>				 * <li>draw() state if neccessary</li></ul><p>		 */		protected function init():void		{			// Warning is raised if subclass doesn't not override init()			throw new Error( "WARNING: " + this + " did not override init()" )				}						/**		 * Removes all listeners and prepares the class for disposal.		 *  		 * <p>This function is called whenever the component is removed from the DisplayList. 		 * Concrete classes should always override this function. The overridden function should contain everything required to cleanly dispose of the component. This can include any of the following:		 * <ul><li> Dispose of any child components</li>		 * <li>remove all listeners</li>		 * <li>stop all sounds</li>		 * <li>release all references to cameras and microphones.</li>		 * <li>call clearInterval() on any currently running intervals</li>		 * <li>call stop() on any running Timer objects</li>		 * <li>Close any connected network objects, such as instances of: Loader, URLLoader, Socket, XMLSocket, LocalConnection, NetConnections, and NetStream.</li></ul><p>		 */		public function destroy():void		{			// Warning is raised if subclass doesn't not override destroy()			throw new Error( "WARNING: " + this + " did not override destroy()" )		}			// ------------------------------------------	// EVENTS		// dispatchEvent() optimisation by Grant Skinner		// http://www.gskinner.com/blog/archives/2009/12/making_dispatch.html		/**		* @private		*/		override public function dispatchEvent( e:Event ):Boolean 		{			if ( hasEventListener( e.type ) || e.bubbles ) { return super.dispatchEvent(e) }			return true		}				/**		* @private		*/		private function onAddedToStage( e:Event ):void				{			// listener removed to avoid Flash Player bug: "Event.ADDED_TO_STAGE fires twice"			// see: http://bugs.adobe.com/jira/browse/FP-1569			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage)			// call component init() function			init() 		}				/**		* @private		*/		private function onRemovedFromStage( e:Event ):void			{			// stop the component timeline playhead			stop()			// remove listeners			removeEventListener(Event.ENTER_FRAME, onInvalidate)			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage)			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage)						// call component destroy() function			destroy() 		}		/**		* @private		*/		private function onInvalidate( e:Event ):void		{			removeEventListener(Event.ENTER_FRAME, onInvalidate);			draw();		}			// ------------------------------------------	// DRAW		/**		 * Calling this function schedules a call to the draw() command. Use invalidate() rather than calling draw() directly to avoid making unneccessary redraws.		 */		protected function invalidate():void		{			addEventListener(Event.ENTER_FRAME, onInvalidate, false, 0, true);		}				/**		 * This function can be called directly to force a redraw of the component. The recommended way of managing redraws is to store the state changes and call invalidate() which will buffer requests to avoid overloading draw().		 * 		 * <p>Concrete classes should always override this function. The overridden function should contain everything required to redraw the state of the component. This can include any of the following:		 * <ul><li>redraw size</li>		 * <li>redraw position</li>		 * <li>redraw state etc...</li></ul><p>		 */				public function draw():void		{			// redraw component state here		}	}}