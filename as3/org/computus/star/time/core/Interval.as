/*		====================================================================================	2009 | John Dalziel  | The Computus Engine  |  http://www.computus.org	All source code licenced under The MIT Licence	====================================================================================  	S.T.A.R. Space Time Actionscript Repository*/package org.computus.star.time.core{		import flash.events.Event;	import flash.events.EventDispatcher;	/**	 * An Interval represents a single span time between two <code>Instants</code>.	 * It contains only a temporal value and has no geographical component.	 * An Interval() can be used on it's own or extended.	 * Changing the duration of an Interval will broadcast a CHANGE event.   	 */	public class Interval extends EventDispatcher	{	// ------------------------------------------	// PROPERTIES				/**		 * The starting point in time of the Interval		 */		public var start:Instant				/**		 * The end point in time of the Interval		 */				public var end:Instant				/**		* @private		*/		protected var _duration:Number		// duration between start and end			// ------------------------------------------	// CONSTRUCTOR		/**		 * Creates a new instance of the Interval() class.		 * 		 * <p>The follow parameters are accepted by the constructor:</p>	 	 * <table class=innertable>  		 * <tr><th>Interval()</th><th> sets the start and end time to the current date and time.</th></tr>		 * <tr><th>Interval( d:Instant )</th><th> sets the start and end time to the value of the Instant passed in the constructor.</th></tr>		 * <tr><th>Interval( d1:Instant, d2:Instant )</th><th> sets the start and end time to the values of the Instants passed in the constructor.</th></tr>		 * </table>		 * <p>Values passed into the constructor will be parsed into Instants. This allows the passing of either nothng, a Number, an AS3 Date or and Instant.</p>		 * 		 * @see org.computus.utils.datetime.core.Instant  		 */		public function Interval( ... args ):void		{			// determine how many arguments have been passed into the constructor			var len:int = args.length						// constuct based on params and datatypes			if ( len == 0 )			{				// start and end default to current time and date				start	= new Instant()				end		= new Instant()			}			else if ( len == 1 )			{				// start and end default to the supplied time and date				start 	= new Instant( args[0] )				end		= new Instant( args[0] )			}			else			{				// start and end are set to the supplied time and date				start 	= new Instant( Math.min( args[0], args[1] ) )				end		= new Instant( Math.max( args[0], args[1] ) )			}						// update duration			_duration = end.time - start.time						// add CHANGE event listeners			start.addEventListener( Event.CHANGE, onStartChange )			end.addEventListener( Event.CHANGE, onEndChange )		}				/**		 * Removes all listeners and prepares the class for disposal.		 */		public function destroy():void		{			start.removeEventListener( Event.CHANGE, onStartChange )			start.destroy()			start = null						end.removeEventListener( Event.CHANGE, onEndChange )			end.destroy()			end = null					}			// ------------------------------------------	// EVENTS					/**		* @private		*/		protected function onStartChange( e:Event ):void	{ updateDuration() }		/**		* @private		*/		protected function onEndChange( e:Event ):void		{ updateDuration() }				// ------------------------------------------	// OVERRIDDEN FUNCTIONS					// AS3 docs recommend implementing rather than overriding toString() but FlexBuilder considers it an error.		/**		 * Function to obtain a string representation of the Interval.  	 	 *	  	 * @return the value as a string.		 */		override public function toString():String	{ return duration.toString() }		/**		 * Function to obtain the duration of the Interval.  	 	 *	  	 * @return the duration in millieconds.		 */		public function valueOf():Number			{ return duration }		// ------------------------------------------	// MOVE: moves the start and end points while maintaining the original duration		/**		 * Move the Interval to a new start point whilst maintaining the same duration.		 *		 * @param newStart a valid number. 		 */		public function moveStart( newStart:Number ):void		{			// suspend updates			start.removeEventListener( Event.CHANGE, onStartChange )			end.removeEventListener( Event.CHANGE, onEndChange )							start.time 		= newStart			end.time		= newStart + _duration							// resume updates			start.addEventListener( Event.CHANGE, onStartChange )			end.addEventListener( Event.CHANGE, onEndChange )		}			/**		 * Move the Interval to a new end point whilst maintaining the same duration.		 *		 * @param newEnd a valid number. 		 */		public function moveEnd( newEnd:Number ):void		{			// suspend updates			start.removeEventListener( Event.CHANGE, onStartChange )			end.removeEventListener( Event.CHANGE, onEndChange )							end.time		= newEnd			start.time 		= newEnd - _duration							// resume updates			start.addEventListener( Event.CHANGE, onStartChange )			end.addEventListener( Event.CHANGE, onEndChange )						}		// ------------------------------------------	// DURATION 			 /**		 * The duration of the Interval in milliseconds.		 */				public function get duration():Number 			{ return _duration }				/**		* @private		*/		public function set duration( ms:Number ):void		{			var t:Number = start.time + ms			if ( t != end.time )			{				end.time 	= t				_duration	= ms				dispatchEvent( new Event( Event.CHANGE ) )			} 		}				/**		* @private		*/		protected function updateDuration():void		{			if ( end.time < start.time )			{				// suspend updates				start.removeEventListener( Event.CHANGE, onStartChange )				end.removeEventListener( Event.CHANGE, onEndChange )								// swap values so end always follows the start				var s:Number	= start.time				start.time 		= end.time				end.time		= s								// resume updates				start.addEventListener( Event.CHANGE, onStartChange )				end.addEventListener( Event.CHANGE, onEndChange )							}			_duration = end.time - start.time					}			}}